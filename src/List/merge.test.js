/* eslint-env mocha */
import expect from 'expect';

import Entity from '../Entity';
import List from './index';

describe('List delta()', () => {
  let list, update;

  beforeEach(() => {
    list = new List();
    update = new List();
  });

  it('returns an object', () => {
    const result = list.delta(update);

    expect(result).toBeAn(Object);
  });

  it('sets the item as first if it has no previous index', () => {
    const index = update.append('item');

    const delta = list.delta(update);

    expect(delta.update.value(List.first)).toBe(index);
  });

  it('sets the item as last if there is no next element', () => {
    const index = update.append('item');

    const delta = list.delta(update);

    expect(delta.update.value(List.last)).toBe(index);
  });

  it('merges two elements with one item each', () => {
    const first = list.append('item');
    const second = update.append('item');

    list.merge(update);
    const greater = first > second ? first : second;
    const lesser = first > second ? second : first;

    expect(list.value(List.first)).toBe(greater);
    expect(list.meta(greater).next).toBe(lesser);
  });

  // List indices are generated by `uuid` introducing non-determinacy.
  // This loop makes it much harder to miss 10% chance failures.
  it('deterministically resolves merges of single element lists', () => {
    for (let index = 0; index < 50; index += 1) {
      const list = new List();
      const update = new List();

      const first = list.append('item');
      const second = update.append('item');

      list.merge(update);
      const greater = first > second ? first : second;
      const lesser = first > second ? second : first;

      expect(list.value(List.first)).toBe(greater);
      expect(list.meta(greater).next).toBe(lesser);
    }
  });

  it('does not show updates if both lists are identical', () => {
    const index = list.append('item');
    update[Entity.object][List.first] = { ...list.meta(List.first) };
    update[Entity.object][index] = { ...list.meta(index) };

    const delta = list.merge(update);

    expect(delta.update.meta(List.first)).toBe(null);
    expect(delta.update.meta(index)).toBe(null);
  });
});

describe('List merge()', () => {
  let list;

  beforeEach(() => {
    list = new List();
  });

  it('adds nothing when an empty list is merged', () => {
    const update = new List();
    list.merge(update);

    expect([...list]).toEqual([]);
  });

  it('adds new fields', () => {
    const update = new List();
    update[Entity.object].field = { value: 'member', state: 1 };

    list.merge(update);

    expect([...list]).toEqual(['member']);
  });

  it('ignores stale updates', () => {
    const update = new List();
    update[Entity.object].field = { value: 'old', state: 1 };
    list[Entity.object].field = { value: 'new', state: 2 };

    list.merge(update);

    expect([...list]).toEqual(['new']);
  });

  it('overwrites stale data', () => {
    const update = new List();
    update[Entity.object].field = { value: 'new', state: 2 };
    list[Entity.object].field = { value: 'old', state: 1 };

    list.merge(update);

    expect([...list]).toEqual(['new']);
  });

  it('returns the deltas', () => {
    const update = new List();
    list[Entity.object].other = { value: 'other potato', state: 1 };
    update[Entity.object].potato = { value: 'potato', state: 1 };

    const delta = list.delta(update);

    expect(delta).toEqual(list.merge(update));
  });
});
